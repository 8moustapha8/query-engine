// Generated by CoffeeScript 1.3.1
(function() {
  var CoffeeScript, Js2coffee, codeChanged, coffeeMode, coffeeModeInstance, editor, editors, key, queryEngine, _i, _len, _ref;

  CoffeeScript = window.CoffeeScript;

  queryEngine = window.queryEngine;

  Js2coffee = window.Js2coffee;

  editors = window.editors = {};

  coffeeMode = require('ace/mode/coffee').Mode;

  coffeeModeInstance = new coffeeMode();

  $(window).resize(function() {
    var padHeight, padWidth;
    padWidth = $(window).width() / 2 - 20;
    padHeight = $(window).height() - $('.header:first').height() - 80;
    return $('.pad,.editor').width(padWidth).height(padHeight);
  }).trigger('resize');

  _ref = ['code', 'result'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    key = _ref[_i];
    editor = ace.edit(key);
    editor.setTheme('ace/theme/textmate');
    editor.setShowPrintMargin(false);
    editor.getSession().setMode(coffeeModeInstance);
    editor.setHighlightActiveLine(true);
    editor.getSession().setTabSize(4);
    editor.getSession().setUseSoftTabs(false);
    editors[key] = editor;
  }

  codeChanged = function() {
    var codeCoffeeScript, codeJavaScript, collection, errMessage;
    try {
      codeCoffeeScript = editors.code.getSession().getValue();
      codeJavaScript = CoffeeScript.compile(codeCoffeeScript);
      collection = eval(codeJavaScript);
      return window.updateResults(collection);
    } catch (err) {
      errMessage = err.stack.toString();
      console.log(errMessage);
      return editors.result.getSession().setValue(errMessage);
    }
  };

  window.updateResults = function(collection) {
    var resultArray, resultCoffee, resultJavaScript;
    resultArray = collection != null ? collection.toJSON() : void 0;
    resultJavaScript = JSON.stringify(resultArray);
    resultCoffee = Js2coffee.build("var result = " + resultJavaScript);
    return editors.result.getSession().setValue(resultCoffee);
  };

  editors.code.getSession().on('change', codeChanged);

  editors.code.getSession().setValue("# Create our project collection from an array of models\n# and set several pills that we can use for searching\nprojectCollection = window.queryEngine\n	.createLiveCollection([\n			id: 1\n			title: \"Query Engine\"\n			tags: [\"backbone\", \"node.js\"]\n			description: \"Query-Engine provides extensive Querying, Filtering, and Searching abilities for Backbone.js Collections as well as JavaScript arrays and objects\"\n		,\n			id: 2\n			title: \"Joe\"\n			tags: [\"testing\", \"node.js\"]\n			description: \"Node.js asynchronous testing framework, runner and reporter\"\n	])\n	.setPill('id', {\n		prefixes: ['id:']\n		callback: (model,value) ->\n			valueRegex = queryEngine.createSafeRegex(value)\n			pass = valueRegex.test(model.get('id'))\n			return pass\n	})\n	.setPill('tag', {\n		prefixes: ['tag:']\n		callback: (model,value) ->\n			pass = _.indexOf(model.get('tags'),value) isnt -1\n			return pass\n	})\n	.setPill('name', {\n		prefixes: ['name:']\n		callback: (model,value) ->\n			valueRegex = queryEngine.createSafeRegex(value)\n			pass = valueRegex.test(model.get('name'))\n			return pass\n	})\n\n$searchbar = $('#searchbar').empty()\n$visualsearch = $('<div>').appendTo($searchbar)\nvisualsearch = window.VS.init({\n	container: $visualsearch\n	callbacks:\n		search: (searchString, searchCollection) ->\n			projectCollection.setSearchString(searchString).query()\n			window.updateResults(projectCollection)\n\n		facetMatches: (callback) ->\n			pills = projectCollection.getPills()\n			pillNames = _.keys(pills)\n			callback(pillNames)\n\n		valueMatches: (facet, searchTerm, callback) ->\n			switch facet\n				when 'id'\n					callback  projectCollection.pluck('id')\n				when 'tag'\n					callback  _.uniq  _.flatten  projectCollection.pluck('tags')\n				when 'name'\n					callback  projectCollection.pluck('name')\n})\nvisualsearch.searchBox.value('tag:\"node.js\"');\n\n\n# Return our project collection\nreturn projectCollection");

}).call(this);
