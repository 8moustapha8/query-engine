// Generated by CoffeeScript 1.3.1
(function() {
  var Backbone, Hash, Pill, Query, QueryCollection, exports, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = (typeof window !== "undefined" && window !== null) && window._ || require('underscore');

  Backbone = (typeof window !== "undefined" && window !== null) && window.Backbone || require('backbone');

  util = {
    safeRegex: function(str) {
      return (str || '').replace('(.)', '\\$1');
    },
    createRegex: function(str) {
      return new RegExp(str, 'ig');
    },
    createSafeRegex: function(str) {
      return util.createRegex(util.safeRegex(str));
    },
    toArray: function(value) {
      var item, key, result;
      result = [];
      if (value) {
        if (_.isArray(value)) {
          result = value;
        } else if (_.isObject(value)) {
          for (key in value) {
            if (!__hasProp.call(value, key)) continue;
            item = value[key];
            result.push(item);
          }
        } else {
          result.push(value);
        }
      }
      return result;
    },
    filter: function(array, test) {
      var val, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        if (test(val)) {
          _results.push(val);
        }
      }
      return _results;
    },
    reject: function(array, test) {
      var val, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        val = array[_i];
        if (!test(val)) {
          _results.push(val);
        }
      }
      return _results;
    }
  };

  Hash = (function(_super) {

    __extends(Hash, _super);

    Hash.name = 'Hash';

    Hash.prototype.arr = [];

    function Hash(value) {
      var item, key, _i, _len;
      value = util.toArray(value);
      for (key = _i = 0, _len = value.length; _i < _len; key = ++_i) {
        item = value[key];
        this.push(item);
      }
    }

    Hash.prototype.hasIn = function(options) {
      var value, _i, _len;
      options = util.toArray(options);
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        value = this[_i];
        if (__indexOf.call(options, value) >= 0) {
          return true;
        }
      }
      return false;
    };

    Hash.prototype.hasAll = function(options) {
      var empty, pass, value, _i, _len;
      options = util.toArray(options);
      empty = true;
      pass = true;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        value = this[_i];
        empty = false;
        if (__indexOf.call(options, value) < 0) {
          pass = false;
        }
      }
      if (empty) {
        pass = false;
      }
      return pass;
    };

    Hash.prototype.isSame = function(options) {
      var pass;
      options = util.toArray(options);
      pass = this.sort().join() === options.sort().join();
      return pass;
    };

    return Hash;

  })(Array);

  QueryCollection = (function(_super) {

    __extends(QueryCollection, _super);

    QueryCollection.name = 'QueryCollection';

    function QueryCollection() {
      return QueryCollection.__super__.constructor.apply(this, arguments);
    }

    QueryCollection.prototype.model = Backbone.Model;

    QueryCollection.prototype.initialize = function(models, options) {
      var _base;
      _.bindAll(this, 'onChange', 'onParentChange', 'onParentRemove', 'onParentAdd', 'onParentReset');
      this.options = _.extend({}, this.options || {}, options || {});
      this.options.filters = _.extend({}, this.options.filters || {});
      this.options.queries = _.extend({}, this.options.queries || {});
      this.options.pills = _.extend({}, this.options.pills || {});
      (_base = this.options).searchString || (_base.searchString = null);
      this.setFilters(this.options.filters);
      this.setQueries(this.options.queries);
      this.setPills(this.options.pills);
      this.setSearchString(this.options.searchString);
      this.live();
      return this;
    };

    QueryCollection.prototype.getFilter = function(key) {
      return this.options.filters[key];
    };

    QueryCollection.prototype.getFilters = function() {
      return this.options.filters;
    };

    QueryCollection.prototype.setFilters = function(filters) {
      var key, value;
      filters || (filters = {});
      for (key in filters) {
        if (!__hasProp.call(filters, key)) continue;
        value = filters[key];
        this.setFilter(key, value);
      }
      return this;
    };

    QueryCollection.prototype.setFilter = function(name, value) {
      var filters;
      filters = this.options.filters;
      if (value != null) {
        filters[name] = value;
      } else if (filters[name] != null) {
        delete filters[name];
      }
      return this;
    };

    QueryCollection.prototype.getQuery = function(key) {
      return this.options.queries[key];
    };

    QueryCollection.prototype.getQueries = function() {
      return this.options.queries;
    };

    QueryCollection.prototype.setQueries = function(queries) {
      var key, value;
      queries || (queries = {});
      for (key in queries) {
        if (!__hasProp.call(queries, key)) continue;
        value = queries[key];
        this.setQuery(key, value);
      }
      return this;
    };

    QueryCollection.prototype.setQuery = function(name, value) {
      var queries;
      queries = this.options.queries;
      if (value != null) {
        queries[name] = value;
      } else if (queries[name] != null) {
        delete queries[name];
      }
      return this;
    };

    QueryCollection.prototype.getPill = function(key) {
      return this.options.pills[key];
    };

    QueryCollection.prototype.getPills = function() {
      return this.options.pills;
    };

    QueryCollection.prototype.setPills = function(pills) {
      var key, value;
      pills || (pills = {});
      for (key in pills) {
        if (!__hasProp.call(pills, key)) continue;
        value = pills[key];
        this.setPill(key, value);
      }
      return this;
    };

    QueryCollection.prototype.setPill = function(name, value) {
      var pills, searchString;
      pills = this.options.pills;
      searchString = this.options.searchString;
      if (value != null) {
        if (!(value instanceof Pill)) {
          value = new Pill(value);
        }
        if (searchString) {
          value.setSearchString(searchString);
        }
        pills[name] = value;
      } else if (pills[name] != null) {
        delete pills[name];
      }
      return this;
    };

    QueryCollection.prototype.getCleanedSearchString = function() {
      return this.options.cleanedSearchString;
    };

    QueryCollection.prototype.getSearchString = function() {
      return this.options.searchString;
    };

    QueryCollection.prototype.setSearchString = function(searchString) {
      var cleanedSearchString, pills;
      pills = this.options.pills;
      cleanedSearchString = searchString;
      _.each(pills, function(pill, pillName) {
        cleanedSearchString = pill.setSearchString(cleanedSearchString);
        return true;
      });
      this.options.searchString = searchString;
      this.options.cleanedSearchString = cleanedSearchString;
      return this;
    };

    QueryCollection.prototype.hasParentCollection = function() {
      return this.options.parentCollection != null;
    };

    QueryCollection.prototype.getParentCollection = function() {
      return this.options.parentCollection;
    };

    QueryCollection.prototype.setParentCollection = function(parentCollection, skipCheck) {
      if (!skipCheck && this.options.parentCollection === parentCollection) {
        return this;
      }
      this.options.parentCollection = parentCollection;
      this.live();
      return this;
    };

    QueryCollection.prototype.hasModel = function(model) {
      var exists;
      model || (model = {});
      if ((model.id != null) && this.get(model.id)) {
        exists = true;
      } else if ((model.cid != null) && this.getByCid(model.cid)) {
        exists = true;
      } else {
        exists = false;
      }
      return exists;
    };

    QueryCollection.prototype.safeRemove = function(model) {
      var exists;
      exists = this.hasModel(model);
      if (exists) {
        this.remove(model);
      }
      return this;
    };

    QueryCollection.prototype.safeAdd = function(model) {
      var exists;
      exists = this.hasModel(model);
      if (!exists) {
        this.add(model);
      }
      return this;
    };

    QueryCollection.prototype.sortArray = function(comparator) {
      var arr, key, value;
      arr = this.toJSON();
      if (comparator) {
        if (comparator instanceof Function) {
          arr.sort(comparator);
        } else if (comparator instanceof Object) {
          for (key in comparator) {
            if (!__hasProp.call(comparator, key)) continue;
            value = comparator[key];
            if (value === -1) {
              arr.sort(function(a, b) {
                return b[key] - a[key];
              });
            } else if (value === 1) {
              arr.sort(function(a, b) {
                return a[key] - b[key];
              });
            }
          }
        } else {
          throw new Error('Unknown comparator type was passed to QueryCollection::sortArray');
        }
      } else {
        if (this.comparator) {
          return this.sortArray(this.comparator);
        } else {
          throw new Error('Cannot sort a set without a comparator');
        }
      }
      return arr;
    };

    QueryCollection.prototype.query = function() {
      var collection, models;
      collection = this.getParentCollection() || this;
      models = this.test(collection);
      this.reset(models);
      return this;
    };

    QueryCollection.prototype.createChildCollection = function() {
      var collection;
      collection = new QueryCollection().setParentCollection(this);
      return collection;
    };

    QueryCollection.prototype.createLiveChildCollection = function() {
      var collection;
      collection = this.createChildCollection().live(true);
      return collection;
    };

    QueryCollection.prototype.findAll = function(query) {
      var collection;
      collection = this.createChildCollection().setQuery('find', query).query();
      return collection;
    };

    QueryCollection.prototype.findOne = function(query) {
      var collection;
      collection = this.createChildCollection().setQuery('find', query).query();
      if (collection && collection.length) {
        return collection.models[0];
      } else {
        return null;
      }
    };

    QueryCollection.prototype.live = function(enabled) {
      var parentCollection;
      if (enabled == null) {
        enabled = this.options.live;
      }
      this.options.live = enabled;
      if (enabled) {
        this.on('change', this.onChange);
      } else {
        this.off('change', this.onChange);
      }
      parentCollection = this.getParentCollection();
      if (parentCollection != null) {
        if (enabled) {
          parentCollection.on('change', this.onParentChange);
          parentCollection.on('remove', this.onParentRemove);
          parentCollection.on('add', this.onParentAdd);
          parentCollection.on('reset', this.onParentReset);
        } else {
          parentCollection.off('change', this.onParentChange);
          parentCollection.off('remove', this.onParentRemove);
          parentCollection.off('add', this.onParentAdd);
          parentCollection.off('reset', this.onParentReset);
        }
      }
      return this;
    };

    QueryCollection.prototype.add = function(models, options) {
      var model, passedModels, _i, _len;
      options = options ? _.clone(options) : {};
      models = _.isArray(models) ? models.slice() : [models];
      passedModels = [];
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        model = this._prepareModel(model, options);
        if (model && this.test(model)) {
          passedModels.push(model);
        }
      }
      Backbone.Collection.prototype.add.apply(this, [passedModels, options]);
      return this;
    };

    QueryCollection.prototype.create = function(model, options) {
      options = options ? _.clone(options) : {};
      model = this._prepareModel(model, options);
      if (model && this.test(model)) {
        Backbone.Collection.prototype.create.apply(this, [model, options]);
      }
      return this;
    };

    QueryCollection.prototype.onChange = function(model) {
      var pass;
      pass = this.test(model);
      if (!pass) {
        this.safeRemove(model);
      }
      return this;
    };

    QueryCollection.prototype.onParentChange = function(model) {
      var pass;
      pass = this.test(model) && this.getParentCollection().test(model);
      if (pass) {
        this.safeAdd(model);
      } else {
        this.safeRemove(model);
      }
      return this;
    };

    QueryCollection.prototype.onParentRemove = function(model) {
      this.safeRemove(model);
      return this;
    };

    QueryCollection.prototype.onParentAdd = function(model) {
      this.safeAdd(model);
      return this;
    };

    QueryCollection.prototype.onParentReset = function(model) {
      this.reset(this.getParentCollection().models);
      return this;
    };

    QueryCollection.prototype.test = function(data) {
      var booleanReturn, models, passed, query;
      booleanReturn = false;
      if (data.models) {
        models = data.models;
      } else if (_.isArray(data)) {
        models = data;
      } else {
        models = [data];
        booleanReturn = true;
      }
      query = new Query({
        queries: this.getQueries(),
        pills: this.getPills(),
        filters: this.getFilters(),
        cleanedSearchString: this.getCleanedSearchString(),
        searchString: this.getSearchString()
      });
      passed = query.test(models);
      if (booleanReturn) {
        return passed && passed.length;
      } else {
        return passed;
      }
    };

    return QueryCollection;

  })(Backbone.Collection);

  Query = (function() {
    var compoundKeys;

    Query.name = 'Query';

    compoundKeys = ["$and", "$not", "$or", "$nor"];

    function Query(_arg) {
      var compoundQuery, filter, filters, keyType, matchKeys, name, o, pill, pills, queries, query, queryObj, _i, _len;
      queries = _arg.queries, filters = _arg.filters, pills = _arg.pills, this.searchString = _arg.searchString, this.cleanedSearchString = _arg.cleanedSearchString;
      this.$not = __bind(this.$not, this);

      this.$nor = __bind(this.$nor, this);

      this.$or = __bind(this.$or, this);

      this.$and = __bind(this.$and, this);

      compoundQuery = {
        $and: [],
        $not: [],
        $or: [],
        $nor: []
      };
      if (queries) {
        for (name in queries) {
          if (!__hasProp.call(queries, name)) continue;
          query = queries[name];
          matchKeys = _.intersection(compoundKeys, _(query).keys());
          if (matchKeys.length === 0) {
            if (_.isArray(query)) {
              queryObj = {
                $and: query
              };
            } else {
              queryObj = {
                $and: [query]
              };
            }
          } else {
            queryObj = query;
          }
          for (_i = 0, _len = compoundKeys.length; _i < _len; _i++) {
            keyType = compoundKeys[_i];
            if (queryObj[keyType]) {
              compoundQuery[keyType] = compoundQuery[keyType].concat(queryObj[keyType]);
            }
          }
        }
      }
      if (pills && (this.searchString != null)) {
        for (name in pills) {
          if (!__hasProp.call(pills, name)) continue;
          pill = pills[name];
          o = {};
          o[name] = {
            $pill: pill
          };
          compoundQuery.$and.push(o);
        }
      }
      if (filters && (this.cleanedSearchString != null)) {
        for (name in filters) {
          if (!__hasProp.call(filters, name)) continue;
          filter = filters[name];
          o = {};
          o[name] = {
            $filter: filter
          };
          compoundQuery.$and.push(o);
        }
      }
      this.compoundQuery = compoundQuery;
    }

    Query.prototype.test = function(models) {
      var reduce_iterator,
        _this = this;
      reduce_iterator = function(memo, queryKey) {
        var query;
        query = _this.compoundQuery[queryKey];
        if (query.length) {
          return _this[queryKey](memo, query);
        } else {
          return memo;
        }
      };
      return _.reduce(compoundKeys, reduce_iterator, models);
    };

    Query.prototype.$and = function(models, queries) {
      return this.iterator(models, queries, false, util.filter);
    };

    Query.prototype.$or = function(models, queries) {
      return this.iterator(models, queries, true, util.filter);
    };

    Query.prototype.$nor = function(models, queries) {
      return this.iterator(models, queries, true, util.reject);
    };

    Query.prototype.$not = function(models, queries) {
      return this.iterator(models, queries, false, util.reject);
    };

    Query.prototype.iterator = function(models, queries, andOr, filterFunction) {
      var me, parsedQuery;
      me = this;
      parsedQuery = this.parseQuery(queries);
      return filterFunction(models, function(model) {
        var modelValue, q, test, _i, _len;
        for (_i = 0, _len = parsedQuery.length; _i < _len; _i++) {
          q = parsedQuery[_i];
          modelValue = model.get(q.key);
          test = me.performQuery(q.type, q.value, modelValue, model, q.key);
          if (andOr === test) {
            return andOr;
          }
        }
        return !andOr;
      });
    };

    Query.prototype.parseQuery = function(rawQuery) {
      var key, o, q, query, queryArray, query_param, type, value, _i, _len, _results;
      if (rawQuery.length === 1 && _(rawQuery[0]).keys().length > 1) {
        queryArray = (function() {
          var _ref, _results;
          _ref = rawQuery[0];
          _results = [];
          for (key in _ref) {
            query_param = _ref[key];
            o = {};
            o[key] = query_param;
            _results.push(o);
          }
          return _results;
        })();
      } else {
        queryArray = rawQuery;
      }
      _results = [];
      for (_i = 0, _len = queryArray.length; _i < _len; _i++) {
        query = queryArray[_i];
        o = {};
        for (key in query) {
          if (!__hasProp.call(query, key)) continue;
          query_param = query[key];
          o = {
            key: key
          };
          if (_.isRegExp(query_param)) {
            o.type = "$regex";
            o.value = query_param;
          } else if (_.isDate(query_param)) {
            o.type = "$date";
            o.value = query_param;
          } else if (_(query_param).isObject() && !_(query_param).isArray()) {
            for (type in query_param) {
              value = query_param[type];
              if (this.testQueryValue(type, value)) {
                o.type = type;
                switch (type) {
                  case "$elemMatch":
                  case "$relationMatch":
                    o.value = parse_query(value);
                    break;
                  case "$computed":
                    q = {};
                    q[key] = value;
                    o.value = parse_query(q);
                    break;
                  default:
                    o.value = value;
                }
              }
            }
          } else {
            o.type = "$equal";
            o.value = query_param;
          }
          if (o.type === "$equal" && _(o.value).isObject()) {
            o.type = "$oEqual";
          }
        }
        _results.push(o);
      }
      return _results;
    };

    Query.prototype.testQueryValue = function(type, value) {
      switch (type) {
        case "$in":
        case "$nin":
        case "$all":
        case "$any":
          return _.isArray(value);
        case "$size":
          return _.isNumber(value);
        case "$regex":
          return _.isRegExp(value);
        case "$like":
        case "$likeI":
          return _.isString(value);
        case "$between":
          return _.isArray(value) && (value.length === 2);
        case "$cb":
          return _.isFunction(value);
        default:
          return true;
      }
    };

    Query.prototype.performQuery = function(queryType, queryValue, modelValue, model, key) {
      var $beginsWithValue, $endsWithValue, _i, _j, _len, _len1;
      switch (queryType) {
        case "$equal":
          return modelValue === queryValue;
        case "$oEqual":
          return _.isEqual(modelValue, queryValue);
        case "$contains":
          return _.isArray(modelValue) && __indexOf.call(modelValue, queryValue) >= 0;
        case "$has":
          return (new Hash(modelValue)).hasIn(queryValue);
        case "$ne":
          return modelValue !== queryValue;
        case "$lt":
          return (modelValue != null) && (modelValue < queryValue);
        case "$gt":
          return (modelValue != null) && (modelValue > queryValue);
        case "$lte":
          return (modelValue != null) && (modelValue <= queryValue);
        case "$gte":
          return (modelValue != null) && (modelValue >= queryValue);
        case "$between":
          return (queryValue[0] < modelValue && modelValue < queryValue[1]);
        case "$in":
          return (new Hash(queryValue)).hasIn(modelValue) || (new Hash(modelValue)).hasIn(queryValue);
        case "$nin":
          return !((new Hash(queryValue)).hasIn(modelValue) || (new Hash(modelValue)).hasIn(queryValue));
        case "$all":
          return _.isArray(modelValue) && (new Hash(modelValue)).hasAll(queryValue);
        case "$any":
          return _.isArray(modelValue) && _.any(modelValue, function(item) {
            return __indexOf.call(queryValue, item) >= 0;
          });
        case "$size":
          return (modelValue != null ? modelValue.length : void 0) === queryValue;
        case "$exists":
          return (modelValue != null) === queryValue;
        case "$like":
          return _.isString(modelValue) && modelValue.indexOf(queryValue) !== -1;
        case "$likeI":
          return _.isString(modelValue) && modelValue.toLowerCase().indexOf(queryValue.toLowerCase()) !== -1;
        case "$regex":
          return queryValue.test(modelValue);
        case "$cb":
          return queryValue.call(model, modelValue);
        case "$pill":
          return queryValue.test(model);
        case "$filter":
          return queryValue(model, this.cleanedSearchString);
        case "$date":
          return queryValue.toString() === modelValue.toString();
        case "$beginsWith":
        case "$startsWith":
          if (!_.isArray(queryValue)) {
            queryValue = [queryValue];
          }
          for (_i = 0, _len = queryValue.length; _i < _len; _i++) {
            $beginsWithValue = queryValue[_i];
            if (modelValue.substr(0, $beginsWithValue.length) === $beginsWithValue) {
              return true;
            }
          }
          return false;
        case "$endsWith":
        case "$finishesWith":
          if (!_.isArray(queryValue)) {
            queryValue = [queryValue];
          }
          for (_j = 0, _len1 = queryValue.length; _j < _len1; _j++) {
            $endsWithValue = queryValue[_j];
            if (modelValue.substr($endsWithValue.length * -1) === $endsWithValue) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    };

    return Query;

  })();

  Pill = (function() {

    Pill.name = 'Pill';

    Pill.prototype.callback = null;

    Pill.prototype.regex = null;

    Pill.prototype.prefixes = null;

    Pill.prototype.searchString = null;

    Pill.prototype.value = null;

    function Pill(pill) {
      var prefix, regexString, safePrefixes, safePrefixesStr, _i, _len, _ref;
      pill || (pill = {});
      this.callback = pill.callback;
      this.prefixes = pill.prefixes;
      safePrefixes = [];
      _ref = this.prefixes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prefix = _ref[_i];
        safePrefixes.push(util.safeRegex(prefix));
      }
      safePrefixesStr = safePrefixes.join('|');
      regexString = '(' + safePrefixesStr + ')([^\\s]+)';
      this.regex = util.createRegex(regexString);
      this;

    }

    Pill.prototype.setSearchString = function(searchString) {
      var cleanedSearchString, match, value;
      cleanedSearchString = searchString;
      value = null;
      while (match = this.regex.exec(searchString)) {
        value = match[2].trim();
        cleanedSearchString = searchString.replace(match[0], '').trim();
      }
      this.searchString = searchString;
      this.value = value;
      return cleanedSearchString;
    };

    Pill.prototype.test = function(model) {
      var pass;
      pass = null;
      if (this.value != null) {
        pass = this.callback(model, this.value);
      }
      return pass;
    };

    return Pill;

  })();

  exports = {
    safeRegex: util.safeRegex,
    createRegex: util.createRegex,
    createSafeRegex: util.createSafeRegex,
    toArray: util.toArray,
    Backbone: Backbone,
    Hash: Hash,
    QueryCollection: QueryCollection,
    Query: Query,
    Pill: Pill,
    createCollection: function(models, options) {
      var collection;
      models = util.toArray(models);
      collection = new QueryCollection(models, options);
      return collection;
    },
    createLiveCollection: function(models, options) {
      var collection;
      models = util.toArray(models);
      collection = new QueryCollection(models, options).live(true);
      return collection;
    }
  };

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports = exports;
  } else if (typeof window !== "undefined" && window !== null) {
    window.queryEngine = exports;
  }

}).call(this);
